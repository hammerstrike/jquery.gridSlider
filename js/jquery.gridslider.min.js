(function () { var e = false; window.JQClass = function () { }; JQClass.classes = {}; JQClass.extend = function t(n) { function o() { if (!e && this._init) { this._init.apply(this, arguments) } } var r = this.prototype; e = true; var i = new this; e = false; for (var s in n) { i[s] = typeof n[s] == "function" && typeof r[s] == "function" ? function (e, t) { return function () { var n = this._super; this._super = function (t) { return r[e].apply(this, t || []) }; var i = t.apply(this, arguments); this._super = n; return i } }(s, n[s]) : n[s] } o.prototype = i; o.prototype.constructor = o; o.extend = t; return o } })(); (function ($) { function camelCase(e) { return e.replace(/-([a-z])/g, function (e, t) { return t.toUpperCase() }) } JQClass.classes.JQPlugin = JQClass.extend({ name: "plugin", defaultOptions: {}, regionalOptions: {}, _getters: [], _getMarker: function () { return "is-" + this.name }, _init: function () { $.extend(this.defaultOptions, this.regionalOptions && this.regionalOptions[""] || {}); var e = camelCase(this.name); $[e] = this; $.fn[e] = function (t) { var n = Array.prototype.slice.call(arguments, 1); if ($[e]._isNotChained(t, n)) { return $[e][t].apply($[e], [this[0]].concat(n)) } return this.each(function () { if (typeof t === "string") { if (t[0] === "_" || !$[e][t]) { throw "Unknown method: " + t } $[e][t].apply($[e], [this].concat(n)) } else { $[e]._attach(this, t) } }) } }, setDefaults: function (e) { $.extend(this.defaultOptions, e || {}) }, _isNotChained: function (e, t) { if (e === "option" && (t.length === 0 || t.length === 1 && typeof t[0] === "string")) { return true } return $.inArray(e, this._getters) > -1 }, _attach: function (e, t) { e = $(e); if (e.hasClass(this._getMarker())) { return } e.addClass(this._getMarker()); t = $.extend({}, this.defaultOptions, this._getMetadata(e), t || {}); var n = $.extend({ name: this.name, elem: e, options: t }, this._instSettings(e, t)); e.data(this.name, n); this._postAttach(e, n); this.option(e, t) }, _instSettings: function (e, t) { return {} }, _postAttach: function (e, t) { }, _getMetadata: function (d) { try { var f = d.data(this.name.toLowerCase()) || ""; f = f.replace(/'/g, '"'); f = f.replace(/([a-zA-Z0-9]+):/g, function (e, t, n) { var r = f.substring(0, n).match(/"/g); return !r || r.length % 2 === 0 ? '"' + t + '":' : t + ":" }); f = $.parseJSON("{" + f + "}"); for (var g in f) { var h = f[g]; if (typeof h === "string" && h.match(/^new Date\((.*)\)$/)) { f[g] = eval(h) } } return f } catch (e) { return {} } }, _getInst: function (e) { return $(e).data(this.name) || {} }, option: function (e, t, n) { e = $(e); var r = e.data(this.name); if (!t || typeof t === "string" && n == null) { var i = (r || {}).options; return i && t ? i[t] : i } if (!e.hasClass(this._getMarker())) { return } var i = t || {}; if (typeof t === "string") { i = {}; i[t] = n } this._optionsChanged(e, r, i); $.extend(r.options, i) }, _optionsChanged: function (e, t, n) { }, destroy: function (e) { e = $(e); if (!e.hasClass(this._getMarker())) { return } this._preDestroy(e, this._getInst(e)); e.removeData(this.name).removeClass(this._getMarker()) }, _preDestroy: function (e, t) { } }); $.JQPlugin = { createPlugin: function (e, t) { if (typeof e === "object") { t = e; e = "JQPlugin" } e = camelCase(e); var n = camelCase(t.name); JQClass.classes[n] = JQClass.classes[e].extend(t); new JQClass.classes[n] } } })(jQuery); (function (e) { var t = "imagecube"; var n = 0; var r = 1; var i = 2; var s = 3; e.JQPlugin.createPlugin({ name: t, defaultOptions: { direction: "random", randomSelection: ["up", "down", "left", "right"], speed: 2e3, easing: "linear", repeat: true, pause: 2e3, selection: "forward", shading: true, opacity: .8, imagePath: "", full3D: true, segments: 20, reduction: 30, expansion: 10, lineHeight: [0, 1.25], letterSpacing: [-.4, 0], beforeRotate: null, afterRotate: null }, _getters: ["current", "next"], _instSettings: function (e, t) { return { _position: e.css("position") } }, _postAttach: function (n, r) { n.css({ position: "relative" }).children().each(function () { var i = e(this); i.data(t, { display: i.css("display"), width: i.css("width"), height: i.css("height"), position: i.css("position"), lineHeight: i.css("lineHeight"), letterSpacing: i.css("letterSpacing") }).css({ display: "block", width: n.css("width"), height: n.css("height"), position: "absolute", lineHeight: r.options.lineHeight[1], letterSpacing: r.options.letterSpacing[1] }) }).not(":first").hide(); this._prepareRotation(n) }, _optionsChanged: function (t, n, r) { e.extend(n.options, r); this._prepareRotation(t) }, _prepareRotation: function (t) { t = e(t); t.children(".imageCubeShading,.imageCubeFrom,.imageCubeTo").remove(); var n = this._getInst(t[0]); n.current = t.children(":visible")[0]; n.current = n.current ? n.current : t.children(":first")[0]; var r = function (e) { return !e.length ? e : e.filter(":eq(" + Math.floor(Math.random() * e.length) + ")") }; n.next = n.options.selection == "random" ? r(t.children(":hidden")) : n.options.selection == "backward" ? e(n.current).prev() : e(n.current).next(); n.next = (n.next.length ? n.next : n.options.selection == "random" ? n.current : n.options.selection == "backward" ? t.children(":last") : t.children(":first"))[0]; if (n.options.repeat && !n._timer) { var i = this; n._timer = setTimeout(function () { i.rotate(t) }, n.options.pause) } }, rotate: function (n, r, i) { n = e(n); if (!n.hasClass(this._getMarker())) { return } if (typeof r == "function") { i = r; r = null } this.stop(n, true); var s = this._getInst(n[0]); if (r != null) { r = typeof r == "number" ? n.children(":eq(" + r + ")") : e(r); if (n.children().filter(function () { return this === r[0] }).length > 0) { s.next = r } } var o = [s.current, s.next]; if (e.isFunction(s.options.beforeRotate)) { s.options.beforeRotate.apply(n[0], o) } var u = {}; u[t] = 1; n.attr(t, 0).stop(true, true).animate(u, s.options.speed, s.options.easing, function () { if (e.isFunction(s.options.afterRotate)) { s.options.afterRotate.apply(n[0], o) } if (i) { i.apply(n[0]) } }) }, current: function (t) { t = e(t); return t.hasClass(this._getMarker()) ? this._getInst(t[0]).current : null }, next: function (t) { t = e(t); return t.hasClass(this._getMarker()) ? this._getInst(t[0]).next : null }, stop: function (t, n) { t = e(t); if (!t.hasClass(this._getMarker())) { return } var r = this._getInst(t[0]); if (r._timer) { clearTimeout(r._timer); r._timer = null } if (!n) { r.options.repeat = false } }, next: function (e) { this.option(e, { repeat: true }) }, _preDestroy: function (n, r) { this.stop(n); var r = this._getInst(n[0]); n.stop().css({ position: r._position }).children(".imageCubeShading,.imageCubeFrom,.imageCubeTo").remove(); n.children().each(function () { var n = e(this); n.css(n.data(t)).removeData(t) }).show() }, _prepareAnimation: function (t) { t = e(t); var o = this._getInst(t[0]); var u = { left: 0, top: 0 }; t.parents().each(function () { var t = e(this); if (t.css("position") == "fixed") { u.left -= t.offset().left; u.top -= t.offset().top; return false } }); var a = { width: t.width(), height: t.height() }; var f = o.options.direction != "random" ? o.options.direction : o.options.randomSelection[Math.floor(Math.random() * o.options.randomSelection.length)]; f = Math.max(0, e.inArray(f, ["up", "down", "left", "right"])); o._curDirection = f; var l = f == n || f == r; var c = f == i || f == s; var h = f == n || f == i; var p = h ? 0 : o.options.opacity; var d = e(o.current); var v = e(o.next); var m = []; var g = function (t) { var n = [0, 0, 0, 0]; if (t.css("border") != undefined) { e.each(["Left", "Right", "Top", "Bottom"], function (e, r) { n[e] = t.css("border" + r + "Width"); n[e] = parseFloat({ thin: 1, medium: 3, thick: 5 }[n[e]] || n[e]) }) } return n }; m[0] = g(d); m[1] = g(v); var y = []; y[0] = [parseFloat(d.css("padding-left")), parseFloat(d.css("padding-right")), parseFloat(d.css("padding-top")), parseFloat(d.css("padding-bottom"))]; y[1] = [parseFloat(v.css("padding-left")), parseFloat(v.css("padding-right")), parseFloat(v.css("padding-top")), parseFloat(v.css("padding-bottom"))]; var b = []; b[0] = e.support.boxModel ? [m[0][0] + m[0][1] + y[0][0] + y[0][1], m[0][2] + m[0][3] + y[0][2] + y[0][3]] : [0, 0]; b[1] = e.support.boxModel ? [m[1][0] + m[1][1] + y[1][0] + y[1][1], m[1][2] + m[1][3] + y[1][2] + y[1][3]] : [0, 0]; var w = []; w[0] = { elem: d[0], props: { left: { next: u.left, end: u.left + (f == s ? a.width : 0), units: "px" }, width: { next: a.width - b[0][0], end: l ? a.width - b[0][0] : 0, units: "px" }, top: { next: u.top, end: u.top + (f == r ? a.height : 0), units: "px" }, height: { next: a.height - b[0][1], end: l ? 0 : a.height - b[0][1], units: "px" }, paddingLeft: { next: y[0][0], end: c ? 0 : y[0][0], units: "px" }, paddingRight: { next: y[0][1], end: c ? 0 : y[0][1], units: "px" }, paddingTop: { next: y[0][2], end: l ? 0 : y[0][2], units: "px" }, paddingBottom: { next: y[0][3], end: l ? 0 : y[0][3], units: "px" }, borderLeftWidth: { next: m[0][0], end: c ? 0 : m[0][0], units: "px" }, borderRightWidth: { next: m[0][1], end: c ? 0 : m[0][1], units: "px" }, borderTopWidth: { next: m[0][2], end: l ? 0 : m[0][2], units: "px" }, borderBottomWidth: { next: m[0][3], end: l ? 0 : m[0][3], units: "px" }, lineHeight: { next: o.options.lineHeight[1], end: l ? o.options.lineHeight[0] : o.options.lineHeight[1], units: "em" }, letterSpacing: { next: o.options.letterSpacing[1], end: l ? o.options.letterSpacing[1] : o.options.letterSpacing[0], units: "em" } } }; w[1] = { elem: v[0], props: { left: { next: u.left + (f == i ? a.width : 0), end: u.left, units: "px" }, width: { next: l ? a.width - b[1][0] : 0, end: a.width - b[1][0], units: "px" }, top: { next: u.top + (f == n ? a.height : 0), end: u.top, units: "px" }, height: { next: l ? 0 : a.height - b[1][1], end: a.height - b[1][1], units: "px" }, paddingLeft: { next: c ? 0 : y[1][0], end: y[1][0], units: "px" }, paddingRight: { next: c ? 0 : y[1][1], end: y[1][1], units: "px" }, paddingTop: { next: l ? 0 : y[1][2], end: y[1][2], units: "px" }, paddingBottom: { next: l ? 0 : y[1][3], end: y[1][3], units: "px" }, borderLeftWidth: { next: c ? 0 : m[1][0], end: m[1][0], units: "px" }, borderRightWidth: { next: c ? 0 : m[1][1], end: m[1][1], units: "px" }, borderTopWidth: { next: l ? 0 : m[1][2], end: m[1][2], units: "px" }, borderBottomWidth: { next: l ? 0 : m[1][3], end: m[1][3], units: "px" }, lineHeight: { next: l ? o.options.lineHeight[0] : o.options.lineHeight[1], end: o.options.lineHeight[1], units: "em" }, letterSpacing: { next: l ? o.options.letterSpacing[1] : o.options.letterSpacing[0], end: o.options.letterSpacing[1], units: "em" } } }; if (o.options.shading) { var E = function (e, t, n) { return { left: { next: e.left.next, end: e.left.end, units: "px" }, width: { next: e.width.next, end: e.width.end, units: "px" }, top: { next: e.top.next, end: e.top.end, units: "px" }, height: { next: e.height.next, end: e.height.end, units: "px" }, paddingLeft: { next: e.paddingLeft.next + e.borderLeftWidth.next, end: e.paddingLeft.end + e.borderLeftWidth.end, units: "px" }, paddingRight: { next: e.paddingRight.next + e.borderRightWidth.next, end: e.paddingRight.end + e.borderRightWidth.end, units: "px" }, paddingTop: { next: e.paddingTop.next + e.borderTopWidth.next, end: e.paddingTop.end + e.borderTopWidth.end, units: "px" }, paddingBottom: { next: e.paddingBottom.next + e.borderBottomWidth.next, end: e.paddingBottom.end + e.borderBottomWidth.end, units: "px" }, opacity: { next: t, end: n, units: "" } } }; w[2] = { elem: e((!e.support.opacity ? '<img src="' + o.options.imagePath + 'imageCubeHigh.png"' : "<div") + ' class="imageCubeShading" style="background-color: white; opacity: ' + p + '; z-index: 10; position: absolute;"' + (!e.support.opacity ? "/>" : "></div>"))[0], props: E(w[h ? 0 : 1].props, p, o.options.opacity - p) }; w[3] = { elem: e((!e.support.opacity ? '<img src="' + o.options.imagePath + 'imageCubeShad.png"' : "<div") + ' class="imageCubeShading" style="background-color: black; opacity: ' + (o.options.opacity - p) + '; z-index: 10; position: absolute;"' + (!e.support.opacity ? "/>" : "></div>"))[0], props: E(w[h ? 1 : 0].props, o.options.opacity - p, p) } } if (o.options.full3D) { for (var S = 0; S < o.options.segments; S++) { t.append(d.clone().addClass("imageCubeFrom").css({ display: "block", position: "absolute", overflow: "hidden" })); if (o.options.shading) { t.append(e(w[h ? 2 : 3].elem).clone()) } } for (var S = 0; S < o.options.segments; S++) { t.append(v.clone().addClass("imageCubeTo").css({ display: "block", position: "absolute", width: 0, overflow: "hidden" })); if (o.options.shading) { t.append(e(w[h ? 3 : 2].elem).clone()) } } d.hide(); v.css({ width: a.width - b[1][0], height: a.height - b[1][1] }) } else { var x = function (e) { return { left: e.left.next + "px", width: e.width.next + "px", top: e.top.next + "px", height: e.height.next + "px", lineHeight: e.lineHeight.next + "em", padding: e.paddingTop.next + "px " + e.paddingRight.next + "px " + e.paddingBottom.next + "px " + e.paddingLeft.next + "px", borderLeftWidth: e.borderLeftWidth.next + "px", borderRightWidth: e.borderRightWidth.next + "px", borderTopWidth: e.borderTopWidth.next + "px", borderBottomWidth: e.borderBottomWidth.next + "px", letterSpacing: e.letterSpacing.next + "em", overflow: "hidden" } }; d.css(x(w[0].props)); v.css(x(w[1].props)).show(); if (o.options.shading) { t.append(w[2].elem).append(w[3].elem) } } for (var S = 0; S < w.length; S++) { for (var T in w[S].props) { var N = w[S].props[T]; N.diff = N.end - N.next } } return w }, _drawFull3D: function (s, o, u) { s = e(s); var a = s.data(t); if (!a.options.full3D) { return false } var f = a._curDirection; var l = f == n || f == r; var c = f == n || f == i; var h = s.width(); var p = s.height(); if (h == 0 || p == 0) { return true } var d = (1 - o) * (l ? p : h); var v = a.options.segments; var m = a.options.expansion * (1 - Math.abs(2 * d - (l ? p : h)) / (l ? p : h)); var g = a.options.reduction - a.options.reduction * d / (l ? p : h); var y = function (t, n, r, i, u, f, c, h, p, d, m, g) { var y = [i - n, f - h]; var b = Math.max(y[0], y[1]); var w = [p - r, c - u]; var E = Math.max(w[0], w[1]); var S = l ? (y[0] - y[1]) / (v - 1) / 2 : b / v; var x = l ? E / v : (w[0] - w[1]) / (v - 1) / 2; var T = m.paddingLeft[g] + m.paddingRight[g] + m.borderLeftWidth[g] + m.borderRightWidth[g]; var N = m.paddingTop[g] + m.paddingBottom[g] + m.borderTopWidth[g] + m.borderBottomWidth[g]; var C = Math.round(n); var k = Math.round(r); var A = C; var O = k; var M = 0; for (var _ = 0; _ < s[0].childNodes.length; _++) { var D = s[0].childNodes[_]; if (D.className != t) { continue } var P = Math.round(n + (M + 1) * S); var B = Math.round(r + (M + 1) * x); var j = y[0] - (l ? 2 * M * S : 0); var F = w[0] - (l ? 0 : 2 * M * x); D.style.left = (l ? A : n) + "px"; D.style.top = (l ? r : O) + "px"; D.style.width = Math.max(0, j - T) + "px"; D.style.height = Math.max(0, F - N) + "px"; D.style.letterSpacing = (l ? j / b * (a.options.letterSpacing[1] - a.options.letterSpacing[0]) + a.options.letterSpacing[0] : o * m.letterSpacing.diff + m.letterSpacing.next) + m.letterSpacing.units; D.style.lineHeight = (!l ? F / E * (a.options.lineHeight[1] - a.options.lineHeight[0]) + a.options.lineHeight[0] : o * m.lineHeight.diff + m.lineHeight.next) + m.lineHeight.units; D.style.clip = "rect(" + (!l ? "auto" : O - k + "px") + "," + (l ? "auto" : P - C + "px") + "," + (!l ? "auto" : B - k + "px") + "," + (l ? "auto" : A - C + "px") + ")"; if (a.options.shading) { var I = D.nextSibling; I.style.left = A + "px"; I.style.top = O + "px"; I.style.width = (l ? y[0] - 2 * M * S : P - A) + "px"; I.style.height = (l ? B - O : w[0] - 2 * M * x) + "px"; I.style.opacity = d; if (!e.support.opacity) { I.style.filter = "alpha(opacity=" + d * 100 + ")" } } A = P; O = B; M++ } }; y("imageCubeFrom", [g, -m, 0, h - d][f], [0, p - d, g, -m][f], [h - g, h + m, d, h][f], [0, p - d, -m, g][f], [h + m, h - g, d, h][f], [d, p, p + m, p - g][f], [-m, g, 0, h - d][f], [d, p, p - g, p + m][f], !a.options.shading ? 0 : (c ? o : 1 - o) * u[2].props.opacity.diff + u[2].props.opacity.next, u[0].props, "next"); y("imageCubeTo", [-m, a.options.reduction - g, d, 0][f], [d, 0, -m, a.options.reduction - g][f], [h + m, h - (a.options.reduction - g), h, h - d][f], [d, 0, a.options.reduction - g, -m][f], [h - (a.options.reduction - g), h + m, h, h - d][f], [p, p - d, p - (a.options.reduction - g), p + m][f], [a.options.reduction - g, -m, d, 0][f], [p, p - d, p + m, p - (a.options.reduction - g)][f], !a.options.shading ? 0 : (c ? o : 1 - o) * u[3].props.opacity.diff + u[3].props.opacity.next, u[1].props, "end"); return true } }); e.fx.step[t] = function (t) { if (!t.stepProps) { t.next = 0; t.end = 1; t.stepProps = e.imagecube._prepareAnimation(t.elem); var n = t.stepProps[0].elem; t.saveCSS = { borderLeftWidth: n.style.borderLeftWidth, borderRightWidth: n.style.borderRightWidth, borderTopWidth: n.style.borderTopWidth, borderBottomWidth: n.style.borderBottomWidth, padding: n.style.padding } } if (!e.imagecube._drawFull3D(t.elem, t.pos, t.stepProps)) { for (var r = 0; r < t.stepProps.length; r++) { var i = t.stepProps[r]; for (var s in i.props) { var o = i.props[s]; i.elem.style[s] = t.pos * o.diff + o.next + o.units; if (!e.support.opacity && s == "opacity") { i.elem.style.filter = "alpha(opacity=" + (t.pos * o.diff + o.next) * 100 + ")" } } } } if (t.pos == 1) { e(t.stepProps[0].elem).hide().css(t.saveCSS); e(t.stepProps[1].elem).show(); e.imagecube._prepareRotation(t.elem) } } })(jQuery); (function (e) { e.fn.gridSlider = function (t) { function a(e) { this.pattern = e.pattern; this.images = e.images; this.length = e.images.length; this.height = e.height; this.width = e.width; this.cols = e.cols; this.rows = e.rows } var n = 0, r = -1, i, s = new Array, o = "", u = e.Deferred(); a.prototype.init = function () { e.imagecube.setDefaults({ speed: 1e3, pause: 2e3, shading: true, direction: "left" }); f.html(""); var t, n; for (t = 1; t <= this.rows; t++) { f.append('<div class="grid_row"></div>'); var r = new Array; for (n = 1; n <= this.cols; n++) { e(f.find(".grid_row")[t - 1]).append('<div class="grid-col col_' + t + n + '"></div>'); r.push(".col_" + t + n) } s.push(r); o = s.join(",") } e(".grid_row .grid-col").css({ width: this.width, height: this.height }); f.find(".grid-col").animate({ opacity: "0" }, 0); i = c.rows - 2 }; a.prototype.nextPattern = function (t, n, r) { for (var i = 0; i < s[r].length; i++) { e(s[r][i]).html('<img src="' + this.setImages() + '"/><img src="' + this.setImages() + '"/>'); e(e(s[r][i] + " img")[0]).hide(0) } e(t).animate({ opacity: "1" }, 1e3); setTimeout(function () { for (var t = 0; t < s[r].length; t++) { e(s[r][t]).imagecube("next") } }, 1e3); setTimeout(function () { e(n).animate({ opacity: "0" }, 1e3) }, 1500) }; a.prototype.setImages = function () { n++; if (n > this.length - 1) { n = 0 } return this.images[n] }; a.prototype.patternCall = function () { e(o).imagecube(); e(o).imagecube("stop"); if (r < c.rows - 1) { r++ } else { r = 0 } if (i < s.length - 1) { i++ } else { i = 0 } var t = s[r].join(","), n = s[i].join(","); c.nextPattern(t, n, r) }; var f = e(this); console.log(f); var l = { pattern: "3x3", cols: 3, rows: 3, height: "150px", width: "270px" }; var t = e.extend({}, l, t); var c = new a(t); var h = Number(t.rows) * Number(t.cols); u.done(c.init()).done(function () { }).done(setTimeout(function () { c.patternCall() }, 100)).done(function () { }).done(setInterval(c.patternCall, 4500)); u.resolve() } })(jQuery)